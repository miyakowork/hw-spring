# 实现思路

之前讲解的视频中只实现了解析 ```select```，本示例我们将新增insert、update以及delete的标签解析。

由于之前只有一个类型（select），无须判断执行SQL的类型，但是本示例需要执行多种类型的SQL，所以我们此处就需要有一个值来判断当前执行的SQL类型，本示例我们增加了一个 ```MethodType``` 枚举来包装SQL的类型。

接下来，我们根据之前的思路需要通过JDK的动态代理来生成对应的Mapper来执行相应的SQL，所以我们需要在之前的 ```SqlSession``` 中添加执行 ```update```/```insert```/```delete``` 的通用方法（但是此处有一点说明，因为 ```jdbc```底层执行此3种方法都是 ```executeUpdate()```，所以我们只需要新增一个 ```update()``` 方法就能够包括这3种情况）。

具体的 u/i/d 执行过程我们则新增到 ```SimpleExecutor``` 中即可（同样也是一个 ```update()``` 方法接口）



> 视频讲解中有一处BUG（未对设置的 pkJavaProp 进行读取设置，源码已修改）

# 新增 class

- ```MethodType```

 ```java 
// 用于标识当前 mapperStatement 的语句类型
 com.lagou.enums.MethodType;
 ```

```java
public enum MethodType {
    /**
     * 目前示例演示此4种
     */
    SELECT,
    UPDATE,
    INSERT,
    DELETE;

    public static MethodType getTypeByXmlTag(String xmlTag) {
        switch (xmlTag) {
            case "select":
                return MethodType.SELECT;
            case "update":
                return MethodType.UPDATE;
            case "insert":
                return MethodType.INSERT;
            case "delete":
                return MethodType.DELETE;
            default:
                throw new RuntimeException("未识别的方法");
        }
    }
}
```



# 新增逻辑/代码

- ## ```XMLMapperBuilder```

  > 新增解析  ```update```/```insert```/```delete``` 标签方法，同时解析当前 statement 的类型以及 自增属性是否开启

  ```java
  //line: 31~38
  //======补充其他标签属性的==============
  List<Element> insertListElements = rootElement.selectNodes("//insert");
  List<Element> updateListElements = rootElement.selectNodes("//update");
  List<Element> deleteListElements = rootElement.selectNodes("//delete");
  //计算集合
  allElements.addAll(insertListElements);
  allElements.addAll(updateListElements);
  allElements.addAll(deleteListElements);
  ```

  ```java
  //line: 51~55
  //补充executeType:
  for (Element element : allElements) {
  	//...
  	//补充executeType:
      MethodType methodType = MethodType.getTypeByXmlTag(element.getQName().getName());
      mappedStatement.setExecuteType(methodType);
      String attr = element.attributeValue("useGeneratedKeys");
      mappedStatement.setUseGeneratedKeys(MethodType.INSERT.equals(methodType) && "true".equalsIgnoreCase(attr));
      String idProp = element.attributeValue("pkJavaProp");
      if (!StringUtils.isNullOrEmpty(idProp)) {
         mappedStatement.setPkJavaProp(idProp);
      }
  
      //...
  }
  ```

  

- ## ```MappedStatement```

  >用于存放每个SQL的类型以及当sql类型为insert的时候是否需要自增主键返回

  ```java
//line: 17~41
    /**
       * 新增属性，方便之后的方法类型识别
       * 执行类型：select、update、delete、insert等（此示例使用此4中示例）
       */
      private MethodType executeType;
      /**
       * 是否需要返回自增主键（如果为insert方法）
       */
      private Boolean useGeneratedKeys;
    /**
       * 主键在java pojo 中的属性名，默认id
       */
      private String pkJavaProp = "id";
  
      public MethodType getExecuteType() {
          return executeType;
      }
  
      public void setExecuteType(MethodType executeType) {
          this.executeType = executeType;
      }
  
      public Boolean getUseGeneratedKeys() {
          return useGeneratedKeys;
      }
  
      public void setUseGeneratedKeys(Boolean useGeneratedKeys) {
          this.useGeneratedKeys = useGeneratedKeys;
      }
  
  
      public String getPkJavaProp() {
          return pkJavaProp;
      }
  
      public void setPkJavaProp(String pkJavaProp) {
          this.pkJavaProp = pkJavaProp;
      }
  ```
  
- ## ```SimpleExecutor```

  > 新增 ```update()``` 方法来执行 DML语句

  ```java
  //line: 74~116
  
      /**
       * DML操作（insert、update、delete等）
       *
       * @param configuration
       * @param ms
       * @param params
       * @return
       * @throws Exception
       */
      @Override
      public int update(Configuration configuration, MappedStatement ms, Object... params) throws Exception {
  
          //1、TODO:此处是要执行删除缓存的操作，此处自定义的框架未涉及
          // clearLocalCache();
  
  
          //2、开始执行DML的相关操作，此处我们使用PreparedStatement
          ////2.1、首先我们与准备下一些属性操作、connection、执行sql、和参数等
          Connection connection = configuration.getDataSource().getConnection();
          String sql = ms.getSql();
          BoundSql boundSql = getBoundSql(sql);
          ////2.2、获取执行预处理对象
          //////判断是否为insert执行方法
          boolean isInsertMethod = ms.getExecuteType().equals(MethodType.INSERT);
          //////如果是insert方法，拉取xml属性是否有配置需要返回自增主键
          /////TODO:此处可能需要去针对不同的数据库来操作（orcale和mysql 主键处理就不同）
          Boolean useGeneratedKeys = ms.getUseGeneratedKeys();
          PreparedStatement ps;
          if (isInsertMethod && useGeneratedKeys) {
              ps = connection.prepareStatement(boundSql.getSqlText(), Statement.RETURN_GENERATED_KEYS);
          } else {
              ps = connection.prepareStatement(boundSql.getSqlText(), Statement.NO_GENERATED_KEYS);
          }
          ////2.3、设置参数
          setExecuteParam(ms, boundSql, ps, params);
          ////2.4、执行DML语句
          ps.executeUpdate();
          ////2.4.1、看看有没有自增主键返回，如果有设置到实体中
          ResultSet rs = ps.getGeneratedKeys();
          if (rs.next()) {
              //可能有多个，但是我们规定约束下插入实体的属性放在取第一个就好
              if (params != null && params.length > 0) {
                  // java 类中 主键属性字段名
                  String columnName = ms.getPkJavaProp();
                  //获取参数实例
                  Class<?> parameterTypeClass = params[0].getClass();
                  //获取自增的主键值
                  Object value = rs.getInt(1);
                  //使用反射或者内省，根据数据库表和实体的对应关系，完成封装
                  PropertyDescriptor propertyDescriptor = new PropertyDescriptor(columnName, parameterTypeClass);
                  Method writeMethod = propertyDescriptor.getWriteMethod();
                  writeMethod.invoke(params[0], value);
              }
          }
  
          ////2.5、返回执行的结果影响行数
          int affectRows = ps.getUpdateCount();
  
          //3、返回执行影响的条数
          return affectRows;
      }
  ```

- ## ```SqlSession``` 和 ```DefaultSqlSession```

> 重写 ```getMapper()``` 方法，使得方法能够支持 CRUD 全部类型，方法名改为 ```getMapperExt()```
>
> 同时也要有处理非 select 的方法 和统一 select 和 update 处理的 内部方法，命名为 ```execute()```

```java
//line: 71~137
    /**
     * dml insert、delete、update执行方法
     *实际的调用方法
     * @param statementId
     * @param params
     * @return
     * @throws Exception
     */
    @Override
    public int update(String statementId, Object... params) throws Exception {
        //调用simpleExecutor
        SimpleExecutor simpleExecutor = new SimpleExecutor();
        MappedStatement mappedStatement = configuration.getMappedStatementMap().get(statementId);
        return simpleExecutor.update(configuration, mappedStatement, params);
    }

    /**
     * 根据xml的标签类型调用不同的查询方法类型
     *
     * @param mapperClass Mapper接口类
     * @return
     */
    @Override
    public <T> T getMapperExt(Class<T> mapperClass) {
        //使用JDK的动态代理生成动态代理类
        //noinspection unchecked
        return (T) Proxy.newProxyInstance(DefaultSqlSession.class.getClassLoader(), new Class[]{mapperClass}, (proxy, method, args) -> {
            //获取statementId
            String methodName = method.getName();
            String className = method.getDeclaringClass().getName();
            String statementId = className + "." + methodName;
            return execute(method, args, statementId);
        });
    }


    /**
     * 通用执行方法：即 select、insert、update、delete全部往此方法走
     * 通过此方法来判断具体走哪个实现方法
     *
     * @param method
     * @param args
     * @param statementId
     * @return
     * @throws Exception
     */
    private Object execute(Method method, Object[] args, String statementId) throws Exception {
        //调用simpleExecutor
        MappedStatement mappedStatement = configuration.getMappedStatementMap().get(statementId);
        MethodType executeType = mappedStatement.getExecuteType();
        if (MethodType.SELECT.equals(executeType)) {
            // 获取被调用方法的返回值类型，如果是list 则执行selectList
            Type genericReturnType = method.getGenericReturnType();
            // 判断是否进行了 泛型类型参数化
            if (genericReturnType instanceof ParameterizedType) {
                return selectList(statementId, args);
            }
            return selectOne(statementId, args);
        }
        //除了select就是目前作业项目中就是insert、delete和update
        //都执行 update底层方法
        else {
            return update(statementId, args);
        }
    }
```

# 测试

## ```IMyPersistenceTest```

> 详情见 class ：```com.lagou.test.IMyPersistenceTest.java```